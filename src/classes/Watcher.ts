import Chokidar, { FSWatcher } from "chokidar";
import path from "path";

import {
    Config,
    WatcherEvent,
    WatcherEvents,
    WatcherListeners
} from "../interfaces";

import { Provider } from "./Provider";
import { Thread } from "./Thread";

import { generateBasePathRelativeToRoot } from "../utils";

/**
 * The base watcher class, that handles all file watches and fires events accordingly.
 */
export class Watcher extends Provider {
    /**
     * The paths generated by this `Watcher` instance, using the config.
     */
    private paths: string | string[];

    /**
     * The root path generated by this `Watcher` instance, using the config.
     */
    private root: string;

    /**
     * The instance of the `chokidar` watcher that powers this wrapper class.
     */
    private instance: FSWatcher;

    /**
     * The instance of `Thread` which manages the execution of commands on firing of watcher event.
     */
    private thread: Thread;

    /**
     * The list of handlers attached to events in this instance. Handlers can be attached to the `onBeforeStart`, `onStart`, `onBeforeChange`, `onChange`, `onBeforeStop` or `onStop` events.
     */
    private listeners: WatcherListeners;

    /**
     * Creates an instance of the `Watcher`.
     * @param {Config} config The base configuration for the watcher.
     * @param {WatcherListeners} [listeners] Optional listeners than can be passed to run custom functions before or after emitted events.
     */
    constructor(config: Config, listeners: WatcherListeners) {
        super(config);
        this.listeners = listeners;
        const { paths, root, ignored = undefined } = this.config;
        this.root = path.join(process.cwd(), root);
        this.paths = generateBasePathRelativeToRoot(this.root, paths);

        this.log.debug("Generated paths for watching", this.paths);

        /**
         * The raw chokidar instance which watches for changes and fires events.
         */
        try {
            this.instance = Chokidar.watch(this.paths, {
                ignored,
                persistent: true,
                ignoreInitial: true
            });
        } catch (error) {
            throw error;
        }

        /**
         * Start an instance of process handler, which manages the spawned process.
         */
        this.thread = new Thread(this.config);
        this.bindWatcherEvents();
    }

    private async bindWatcherEvents(): Promise<void> {
        this.instance.on("ready", async () => {
            await this.thread.start(this.root);
            console.log("");
        });

        this.instance.on("all", async (res, file) => {
            await this.thread.restart(this.root);
            this.log.debug(
                "EVENT:",
                res,
                "| FILE:",
                path.resolve(this.root, file)
            );
            console.log("");
        });

        this.instance.on("error", async error => {
            this.log.fatal(error);
        });
    }

    /**
     * Allows attaching a handler to an watcher event. Does not attach event if `event` is not valid.
     * @param {WatcherEvent} event The event to fire this function for. Possible options are `onBeforeStart`, `onStart`, `onBeforeChange`, `onChange`, `onBeforeStop` and `onStop`.
     * @param {function} eventHandler The event handler function. Receives
     */
    public on(event: WatcherEvent, eventHandler: Function): void {
        if (!WatcherEvents.hasOwnProperty(event)) {
            this.log.warn(
                `Event '${event}' is not valid. Handler not attached.`
            );
        } else {
            this.listeners[event] = eventHandler;
        }
    }

    /**
     * Returns the instance of the internal watcher.
     */
    public getInstance(): FSWatcher {
        return this.instance;
    }
}
