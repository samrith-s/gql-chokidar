import Chokidar, { FSWatcher } from "chokidar";
import path from "path";

import {
    Config,
    WatcherEvent,
    WatcherEvents,
    WatcherListeners
} from "../interfaces";

import { Provider } from "./Provider";
import { ProcessHandler } from "./ProcessHandler";

import { generateBasePathRelativeToRoot } from "../utils";

/**
 * The base watcher class, that handles all file watches and fires events accordingly.
 */
export class Watcher extends Provider {
    /**
     * The paths generated by this `Watcher` instance, using the config.
     */
    private paths: string | string[];

    /**
     * The instance of the `chokidar` watcher that powers this wrapper class.
     */
    private instance: FSWatcher;

    /**
     * The instance of `ProcessHandler` which manages the execution of commands on firing of watcher event.
     */
    private processHandler: ProcessHandler;

    /**
     * The list of handlers attached to events in this instance. Handlers can be attached to the `onBeforeStart`, `onStart`, `onBeforeChange`, `onChange`, `onBeforeStop` or `onStop` events.
     */
    private listeners: WatcherListeners;

    /**
     * Creates an instance of the `Watcher`.
     * @param {Config} config The base configuration for the watcher.
     * @param {WatcherListeners} [listeners] Optional listeners than can be passed to run custom functions before or after emitted events.
     */
    constructor(config: Config, listeners: WatcherListeners) {
        super(config);
        const { paths, root, ignored = undefined, watcher } = this.config;

        this.paths = generateBasePathRelativeToRoot(
            path.join(process.cwd(), root),
            paths
        );

        this.log.debug("Generated paths for watching", this.paths);

        /**
         * The raw chokidar instance which watches for changes and fires events.
         */
        try {
            this.instance = Chokidar.watch(this.paths, {
                ...watcher,
                ignored,
                persistent: true,
                ignoreInitial: true
            });
        } catch (error) {
            throw error;
        }

        /**
         * Start an instance of process handler, which manages the spawned process.
         */
        this.processHandler = new ProcessHandler(this.config);
    }

    private eventManager() {}

    /**
     * Allows attaching a handler to an watcher event. Does not attach event if `event` is not valid.
     * @param {WatcherEvent} event The event to fire this function for. Possible options are `onBeforeStart`, `onStart`, `onBeforeChange`, `onChange`, `onBeforeStop` and `onStop`.
     * @param {function} eventHandler The event handler function. Receives
     */
    public on(event: WatcherEvent, eventHandler: Function): void {
        if (!WatcherEvents.hasOwnProperty(event)) {
            this.log.warn(
                `Event '${event}' is not valid. Handler not attached.`
            );
        } else {
            this.listeners[event] = eventHandler;
        }
    }

    /**
     * Returns the instance of the internal watcher.
     */
    public getInstance(): FSWatcher {
        return this.instance;
    }
}
